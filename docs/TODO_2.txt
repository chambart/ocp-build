**************************************************************************
*                                                                        *
*                        TypeRex OCaml Studio                            *
*                                                                        *
*                 Thomas Gazagnaire, Fabrice Le Fessant                  *
*                                                                        *
*  Copyright 2011-2012 OCamlPro                                          *
*  All rights reserved.  This file is distributed under the terms of     *
*  the GNU Public License version 3.0.                                   *
*                                                                        *
*  TypeRex is distributed in the hope that it will be useful,            *
*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
*  GNU General Public License for more details.                          *
*                                                                        *
**************************************************************************

We should take into account the command that was executed to generate
the file.  If the command was changed, we should rebuild the file. It
should take into account any change also in the list of dependencies,
i.e. it should be rebuild if a file is added or removed in a
requirement, or if a requirement is added or removed (that should
appear actually in the command).

How to deal with multiple rules for the same target ? They are generated by:
- different commands generating the same file (.cmi coming with .cmo/.cmx)
- the same files being specified several times

We could save somewhere in the _obuild directory which configuration
was used to compile a particular version. Then, ocp-build would use
that version again and again, even when a new version of ocaml is
installed, until a -clean is called. Then, configuration would be reset
to use the new version.

If the old version was removed, ocp-build would default to the new
version, and display an error if it does not use the same version.

Errors and Warnings should ALWAYS be printed at the end, not during the compilation process.

1. Try to read ocp-build.conf
2. If it fails, try to read ~/.ocp/ocp-build.conf
3. If it fails, execute 'ocamlc -v', hash the result, and try to find the corresponding
     configuration in ~/.ocp/$HASH/ocp-build.conf
4. If it still fails, automatically infer the configuration. If a -global-cache option is
     provided, then save it in ~/.ocp/$HASH/ocp-build.conf. If a -local-cache option is
     provided, then save it in ./ocp-build.conf

TODO Syntax:
============

Improve the syntax with:
- use a better parser (.mly or menhir)
- define "config" packages such that:
    config "config" will load in the current context the configuration "config"
- define "include" directives, to load other files

TODO Compilation:
=================

Files of package "omake-libmojave" should be compiled in:
_obuild/omake-libmojave/...

so that the same files can be compiled several times if they target different
directories.

TODO engine:
============

  Do not quit with exit 2 until all processes have returned (otherwise, some
files might be misleadingly truncated).

(*

TODO list:
- generate projects in different directories
- create dependencies on project descriptions, and use them for dependencies and compiled objects
- install rule

Ajouter un outil de scan permettant de générer les fichiers ocamlconf.ocf
à partir de n'importe quel répertoire.

Prendre en compte la modification des règles de compilation.

Prendre en compte les numéros de version.
_build/
  Project-$version-$sha1(ocamlconf.ocf)/
Définir deux répertoires pour chaque projet: src_dir (les sources), dst_dir
(la destination des fichiers compilés). src_includes fournit la liste des répertoires source pour le calcul des dépendances, tandis que dst_includes sert pour la compilation.

On peut aussi sauvegarder le project dans le répertoire au format binaire
 et calculer son sha1.

Vérifier que la même cible n'apparaissent pas à plusieurs endroits, ou avec
des dépendances vers elle-même.

Definir des "side-effects" des rules, comme des targets n'etant pas directement
le but d'une rule. Par exemple, les .cmi generes par la compilation des .cmo, ou
les .o generes pas la compilation des .cmx.

Utiliser les dépendances à base de modules, au lieu des fichiers... ou définir des
règles pour convertir les noms des fichiers de dépendances en des noms
préfixés en _obuild/

*)


- When no argument is provided, nothing happens !
- We should have an option to display the main targets
- The default verbosity should be 1

BUGS:
- use project_provides when compiling
- fatal error when multiple projects implement the same library

FEATURES:
- implement -debug (generates libraries in .d.cma, .d.cmxa) -> no, in d/ subdirectory
- implement -profile (generates libraries in .p.cmxa) -> no, in p/ subdirectory

Comportement par défaut:
- on cherche dans le répertoire ~/.ocp/, le fichier build-config.conf. Si celui-ci
existe, on s'en sert.
- on cherche dans le répertoire ~/.ocp/ le fichier ocamlconf.ocf de l'installation.
Si celui-ci existe, on s'en sert.
- sinon, on cherche dans le répertoire courant les fichiers _obuild/build-config.conf
et _obuild/ocamlconf.ocf. Pour générer le second, il faut d'abord avoir valider le
premier.

Option -scan: par défaut, build-ocaml scan tous les sous-répertoires
pour trouver les fichier ocamlconf.ocf décrivant le projet. Pour
éviter ce comportement, on utilise l'option -scan ou l'option -use. La
première parcourt tous les répertoires, et crée un fichier
_obuild/ocamlconf.ocf décrivant le projet. Si ce fichier existe,
build-ocaml ne parcourt plus les autres répertoires. L'autre option
est d'utiliser l'option -use <filename>, qui crée aussi un fichier
_obuild/ocamlconf.ocf, contenant uniquement l'instruction include
<filename>, ce qui permet d'éviter de parcourir tous les répertoires.

* Trouver le bon nom pour un tag. Par exemple, choisir le chemin complet du répertoire
n'est probablement pas assez symbolique. Il faudrait plutot avoir un fichier de config
indiquant les répertoires avec des noms symboliques, dont celui de la distribution
standard.

* Vérifier que plusieurs projets ne portent pas le même nom, ou s'ils portent le même
nom, qu'ils portent des tags différents.

* Utiliser les tags portés par les projets:
  - version (on prend toujours la version la plus récente d'un projet)
  - tag (on prend toujours le tag vide par défaut, et un autre uniquement si spécifié)

* Afficher un warning si plusieurs projets ne possèdent pas un tag par défaut

* Plutôt que d'inférer les informations à chaque fois, il faudrait les
stocker qqpart, pour pouvoir les réutiliser, en particulier quand
l'utilisateur à modifier. Peut-être que l'utilisateur ne devrait
jamais modifier le fichier généré, mais uniquement la source de
l'information.

* Utiliser les fichiers META pour trouver les numéros de version.

* Permettre d'inclure tous les fichiers d'un projet, sous la forme
   files = [ "projet:" ]



We want to have also a type "config", where we want to define
flags than can be reused by other packages.

If we have several rules with the same target, we want only one of them
to be used to create the target. Normally, dependencies are correctly
generated,

ocp-build -asm -library libtoto toto.ml   ----> libtoto.cmxa
ocp-build -byte -program x toto.ml   ----> x.byte


----------------------------------------------------------

Quelques mécanismes de substitutions qui pourraient être pratiques:

- substitution dans les chaînes de caractères "$(X)", valeur de la
    variable X. En n2, rechercher en partant de la fin la dernière
    occurrence de ${...}.

- extraction de fichiers d'un projet: pour le projet "toto", on
    peut extraire les fichiers ainsi:
    package "toto" (ml & mli)
    package "toto" (objects)

---------------------------------------------------------

gestion des dépendances d'un paquet:il faut distinguer les
requirements de plusieurs types:

- ceux nécessaires au preprocessing de certains fichiers
    (syntaxes)
- ceux nécessaires à la compilation de certains fichiers
    (interfaces et implémentations)
- ceux nécessaires à la liaison de ces fichiers
    (bibliothèque)

un paquet génère:
- soit une syntaxe
- soit une bibliothèque
- soit un programme

---------------------------------------------------------

Définition d'extensions de syntaxe:

begin syntax "cvt_emit"
  pp = [ program  "cvt_emit" (byte) ]
  pp_shared = false
  requires (syntax) [ program "cvt_emit" ]
  requires (link)   [ "cvt_emit_lib" ]
end


begin objects "lwt-syntax-objects"
  files = [ ... ]
  requires (syntax) [ "camlp4-syntax" "camlp4-extension" ]
end

begin syntax "camlp4-syntax"
  pp = [ "${camlp4}" ]
end

begin syntax "camlp4-extension"
  requires (syntax) [ "camlp4-syntax" ]
  args [ "${camlp4}" ] += [ "pa_qMLast.cmo" ]
end

begin syntax "lwt-syntax"
    (* several syntax extensions can be used with the same prefix *)
  requires (syntax) [ "camlp4-syntax"; "deriving-syntax"; "lwt-syntax-objects" % (byte) ]
  args ["${camlp4}"] += [ "lwt-syntax-objects" % (cmo) ]
end
